#!/usr/bin/env perl
use strict;
use warnings;
use autodie;
use Encode qw(decode);
use List::Util qw(any);
use JSON::PP;


my $identities = decode_json(scalar <STDIN>);


my %identity_map;

for my $i (0 .. $#$identities) {
    for my $identifier (@{$identities->[$i]}) {
        if (exists $identity_map{$identifier}) {
            die "Duplicate identifier '$identifier'\n";
        }
        $identity_map{$identifier} = $i;
    }
}


sub identify {
    my ($first, @rest) = grep { defined } @identity_map{@_};
    return undef unless defined $first;

    if (any { $_ ne $first } @rest) {
        my $keys   = join ', ', grep { defined } @_;
        my $values = join ', ', $first, @rest;
        die "Multiple different identities for $keys: $values\n";
    }

    return int $first;
}


my %commit_map;

while (<STDIN>) {
    my $commit = decode_json($_);
    $commit_map{$commit->{hash}} = {
        %$commit,
        author    => identify(@{$commit}{   'author_name',    'author_mail'}),
        committer => identify(@{$commit}{'committer_name', 'committer_mail'}),
        signer    => identify($commit->{signer}),
    };
}


print JSON::PP->new->utf8->pretty->canonical->encode({
    identities => $identities,
    commits    => \%commit_map,
});


__END__

=head1 NAME

assocman - associate commits with merged identities

=head1 SYNOPSIS

Just run this with C<idman>, it needs the output from both C<graphman> and
C<parseman>, which is non-trivial to do with pipelines on the command line.

=head1 DESCRIPTION

The input on stdin takes the form of one JSON object per line, the first one
being the C<graphman> output and the rest being the C<parseman> output.

The output on stdout will be a pretty-printed JSON object, see F<../README.md>
for the detailed description of the structure.

If a single artifact cannot be clearly mapped to an identity or if a
author/committer/signer resolves to more than one identity, this will die,
overwhelmed from all the ambiguity.

=cut
