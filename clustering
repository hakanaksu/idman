#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import json

## Helper for set-Encoding in json  (to list)
class SetEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        return json.JSONEncoder.default(self, obj)

# Helper Function for only adding non-falsy values
def addToSet(set,el):
    if el:
        set.add(el)
    return set

## Adds the developers participating at the commit to the commit
def learnDev(dataset,com):
    commit = json.loads(com)
    dataset = processSingleDev(dataset,commit['author_name'],commit['author_mail'])
    dataset = processSingleDev(dataset,commit['committer_name'],commit['committer_mail'],commit['signer'],commit['signer_key'])
    return dataset

## Tries to find exsisting developer in dataset and adds him if not found
def processSingleDev(dataset, name, mail, signer=None, skey=None):
    for d in dataset:
         if  name in d['Names'] or isEMailSim(mail,d) or signer in d['Names'] or skey in d['Keys']:
            addToSet(d['Names'],name)
            addToSet(d['Names'],signer) #Signer makes commit
            addToSet(d['Mails'],mail)
            addToSet(d['Keys'],skey)
            return dataset
    tmp={}
    tmp['Names']=addToSet(set(),name)
    tmp['Mails']=addToSet(set(),mail)
    addToSet(tmp['Names'],signer)
    tmp['Keys']=addToSet(set(),skey)
    dataset.append(tmp)
    return dataset

#searches for email-user in exsisting usernames and emails
def isEMailSim(email1, data):
    if not isinstance(email1,basestring):
        return False
    username = email1.split("@")[0]
    for mail in data['Mails']:
        if mail.split('@') == username:
            return True
    for name in data['Names']:
        if username == name:
            return True
    return False

# combines Elements of the dataset if they share values
### ATTENTION: deletes the given dataset
def combineElements(dataset):
	newdata = []
	for d in dataset[:]:
		try:
			dataset.remove(d)
			tmp = d
			for comp in dataset[:]:
				if len(dictIntersection(d,comp)):
					tmp = dictUnion(tmp,comp)
					try:
						dataset.remove(comp)
					except ValueError:
						pass
			newdata.append(tmp)
			#print tmp
		except ValueError:
			continue
	return newdata

## Intersects dictionaries interpreting values as set
def dictIntersection(d1,d2):
	result = {} 
	for k in set(d1.keys()).intersection(set(d2.keys())):
		result[k] = set(d1[k]).intersection(set(d2[k]))
		if not result[k]:
			del result[k]
	return result

## Intersects dictionaries interpreting values as set
def dictUnion(d1,d2):
	result = {} 
	for k in set(d1.keys()).union(set(d2.keys())):
		result[k] = set(d1.get(k,[])).union(set(d2.get(k,[])))
		if not result[k]:
			del result[k]
	return result


if __name__ == "__main__":
	dataset = []
	#inital data aquisition
	for line in sys.stdin:
		dataset=learnDev(dataset,line)
	#minimize dataset
	dsize=0
	while not dsize == len(dataset):#as long as combination is not noop
		dsize=len(dataset)
		dataset = combineElements(dataset)
	for line in dataset:
		print json.dumps(line,cls=SetEncoder)
